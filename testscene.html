<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>test scene</title>

<script type="text/javascript" src="lib/glMatrix-0.9.5.min.js"></script>


<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	uniform vec4 uColor;

	void main(void) {
		gl_FragColor = uColor;
	}
</script>
<!-- vertex shader -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
			
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	}
</script>





<script type="text/javascript">
//will make a simple test scene in this project, with view to combining with code to do stereographic projection
//making a separate project initially to avoid making a mess.
//would like to split up into files better etc
//getShader, initGL should go in a utils file/function since use these all the time
//shaders themselves should go elsewhere.
//might also generalise/modularise drawable objects and put that info in separate files. 
// see http://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html

//scene should allow demonstration of circle/angle preservation. should show some spheres
//being inside a large box also useful to field of view.

//should allow player to control camera. simple way to do this? click and drag to rotate camera ? some buttons to fly forward/backward/left/right/up/down (wasd, )
//http://www.dxx-rebirth.com/frm/index.php?topic=259.0 some control examples


var gl;	//context

//mostly from view-source:http://learningwebgl.com/lessons/lesson01/index.html
function initGL(canvas){
	try {
		gl = canvas.getContext("webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		screenAspect = gl.viewportWidth/gl.viewportHeight;
	} catch (e) {
	}
	if (!gl) {
		alert("Could not initialise WebGL, sorry :-(");
	}
}

function getShader(gl, id) {
	var shaderScript = document.getElementById(id);
	if (!shaderScript) {
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) {
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment") {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex") {
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		return null;
	}

	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

var shaderProgramColored;
function initShaders(){
	shaderProgramColored = loadShader( "shader-simple-vs", "shader-simple-fs",{
					attributes:["aVertexPosition"],
					uniforms:["uPMatrix","uMVMatrix","uColor"]
					});
}

//shader loader function.
function loadShader(vs_id,fs_id, obj) {
	var fragmentShader = getShader(gl, vs_id);		//TODO check whether shader already got
	var vertexShader = getShader(gl, fs_id);

	var shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram, vertexShader);
	gl.attachShader(shaderProgram, fragmentShader);
	gl.linkProgram(shaderProgram);

	if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		alert("Could not initialise shaders");
	}

	shaderProgram.uniforms={};
	shaderProgram.attributes={};
	progUniforms = shaderProgram.uniforms;
	progAttributes = shaderProgram.attributes;
	
	obj.attributes.forEach(function(item, index){
		progAttributes[item] = gl.getAttribLocation(shaderProgram, item);
		gl.enableVertexAttribArray(progAttributes[item]);
	});
	obj.uniforms.forEach(function(item, index){
		console.log("getting uniform location for " + item);
		progUniforms[item] = gl.getUniformLocation(shaderProgram, item);
	});

	return shaderProgram;
}

var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var nMatrix = mat3.create();

var playerMatrix = mat4.create();

function setMatrixUniforms(shaderProgram) {
    gl.uniformMatrix4fv(shaderProgram.uniforms.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.uniforms.uMVMatrix, false, mvMatrix);
}


//drawing a sphere.
//from http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere

var latitudeBands = 8;
var longitudeBands = 16;
var radius = 1.3;

var vertexPositionBuffer;
//var vertexNormalBuffer;
//var vertexTextureCoordBuffer;
var vertexIndexBuffer;


function initBuffers(){
	var vertexPositionData = [];
	var normalData = [];
	var textureCoordData = [];

	//this appears do duplicate vertices along seem but what the hey
	//to do this properly probably should just make a geosphere and subdivide
	//eg http://www.html5gamedevs.com/topic/17786-icosphere-20-sides-polyhedron-uv-subdivide-smoothflat-normals/
	for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
		var theta = latNumber * Math.PI / latitudeBands;
		var sinTheta = Math.sin(theta);
		var cosTheta = Math.cos(theta);
		
		for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
		 var phi = longNumber * 2 * Math.PI / longitudeBands;
		 var sinPhi = Math.sin(phi);
		 var cosPhi = Math.cos(phi);
		
		 var x = cosPhi * sinTheta;
		 var y = cosTheta;
		 var z = sinPhi * sinTheta;
		 var u = 1- (longNumber / longitudeBands);
		 var v = latNumber / latitudeBands;
		
		 normalData.push(x);
		 normalData.push(y);
		 normalData.push(z);
		 textureCoordData.push(u);
		 textureCoordData.push(v);
		 vertexPositionData.push(radius * x);
		 vertexPositionData.push(radius * y);
		 vertexPositionData.push(radius * z);
	   }
	}

	var indexData = [];
	 for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
	   for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
		 var first = (latNumber * (longitudeBands + 1)) + longNumber;
		 var second = first + longitudeBands + 1;
		 indexData.push(first);
		 indexData.push(second);
		 indexData.push(first + 1);
		 indexData.push(second);
		 indexData.push(second + 1);
		 indexData.push(first + 1);
	   }
	}

/*
	vertexNormalBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
	vertexNormalBuffer.itemSize = 3;
	vertexNormalBuffer.numItems = normalData.length / 3;

	vertexTextureCoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
	vertexTextureCoordBuffer.itemSize = 2;
	vertexTextureCoordBuffer.numItems = textureCoordData.length / 2;
*/

	vertexPositionBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
	vertexPositionBuffer.itemSize = 3;
	vertexPositionBuffer.numItems = vertexPositionData.length / 3;

	vertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
	vertexIndexBuffer.itemSize = 3;
	vertexIndexBuffer.numItems = indexData.length;
	
}



function drawScene(frameTime) {
		requestAnimationFrame(drawScene);
		//console.log("drawing...");
	
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		setMVMatToPlayer();
        mat4.translate(mvMatrix, [0.0, 0.0, -10]);
		
		gl.useProgram(shaderProgramColored);
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [1.0, 0.0, 0.0, 1.0]);

		drawSphere();
		
	
		
		var angStep = Math.PI/8;
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [1.0, 1.0, 0.0, 1.0]);
		setMVMatToPlayer();
		mat4.rotateZ(mvMatrix,Math.PI/2);
		
		drawBallRing();
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [0.0, 1.0, 0.0, 1.0]);
		setMVMatToPlayer();
		
		drawBallRing();
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [0.0, 0.0, 1.0, 1.0]);
		setMVMatToPlayer();
		mat4.rotateY(mvMatrix,Math.PI/2);
		drawBallRing();
		
		function setMVMatToPlayer(){
			//mvMatrix= mat4.clone(playerMatrix);	//can apparently do this in a newer version of glMatrix
			mvMatrix = mat4.create();
			mat4.set(playerMatrix, mvMatrix);
		}
		
		function drawBallRing(){
			mat4.rotateX(mvMatrix, angStep/2);
			for (var ii=0;ii<16;ii++){
				mat4.rotateX(mvMatrix, angStep);
				mat4.translate(mvMatrix, [0.0, 0.0, -10]);
				drawSphere();
				mat4.translate(mvMatrix, [0.0, 0.0, 10]);
			}
		}

}

function drawSphere(){
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgramColored.attributes.aVertexPosition, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
    setMatrixUniforms(shaderProgramColored);
				
    gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}







function setupScene() {
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	mat4.perspective(90, gl.viewportWidth / gl.viewportHeight, 0.1, 100, pMatrix);
	
	mat4.identity(playerMatrix);
}


function init(){

	window.addEventListener("keydown",function(evt){
		console.log("key pressed : " + evt.keyCode);
		switch (evt.keyCode){
			case 38:
				movePlayer(0.1);
				break;
			case 40:
				movePlayer(-0.1);
				break;
			case 39:
				turnPlayer(0.02);
				break;
			case 37:
				turnPlayer(-0.02);
				break;
		}
	})


	initGL(document.getElementById("mycanvas"));
	initShaders();
	
	initBuffers();
	gl.clearColor(0.0, 0.1, 0.1, 1.0);
    gl.enable(gl.DEPTH_TEST);
	setupScene();
	requestAnimationFrame(drawScene);
}

var playerPosition = [0,0,0];
function movePlayer(amount){
	//mat4.translate(playerMatrix,[0,0,amount]);
	
	playerPosition[0] += amount*playerMatrix[2];
	playerPosition[1] += amount*playerMatrix[6];
	playerPosition[2] += amount*playerMatrix[10];
	setPlayerTranslation(playerPosition);
	
	//mat4.translate(playerMatrix, [amount*playerMatrix[2], amount*playerMatrix[6], amount*playerMatrix[10]]);
	console.log("" + playerMatrix[0] + ", " + playerMatrix[1] + ", " + playerMatrix[2] + ", " + playerMatrix[3] + ",\n"
				+ playerMatrix[4] + ", " + playerMatrix[5] + ", " + playerMatrix[6] + ", " + playerMatrix[7] + ", \n"
				+ playerMatrix[8] + ", " + playerMatrix[9] + ", " + playerMatrix[10] + ", " + playerMatrix[11] + ", \n"
				+ playerMatrix[12] + ", " + playerMatrix[13] + ", " + playerMatrix[14] + ", " + playerMatrix[15] + ", \n"
				);
}
function turnPlayer(amount){
	playerMatrix[12]=0;	//zero translation components
	playerMatrix[13]=0;
	playerMatrix[14]=0;
	setPlayerTranslation([0,0,0]);	
	mat4.rotateY(playerMatrix, amount);
	setPlayerTranslation(playerPosition);
}

function setPlayerTranslation(posArray){
	playerMatrix[12]=0;	//zero translation components
	playerMatrix[13]=0;
	playerMatrix[14]=0;
	mat4.translate(playerMatrix, posArray);
}


</script>



</head>



<body onload="init()">
<canvas id="mycanvas" width="1366" height="768">CANVAS TO GO HERE</canvas>





</body>


</html>