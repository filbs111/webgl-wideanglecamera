<!DOCTYPE html>
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>test scene</title>

<script type="text/javascript" src="lib/glMatrix-0.9.5.min.js"></script>

<!-- cube mapping for FOV>180 -->
<script id="shader-fullscreen-cube-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform samplerCube uSampler;

	uniform float uVarOne;
	
	void main(void) {
		
		//this works . 2 lines below equivalent. unsure which more efficient. maybe compile to same
		gl_FragColor = textureCube(uSampler, vec3(vTextureCoord.s, -vTextureCoord.t, 2.0 +uVarOne*dot(vTextureCoord,vTextureCoord)));
		//gl_FragColor = textureCube(uSampler, vec3(0.0,0.0,1.0)*(uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3(vTextureCoord.s , vTextureCoord.t  , 2.0));
		
		//gl_FragColor = vec4(vTextureCoord.s,vTextureCoord.t,0.0,1.0);
		//gl_FragColor = vec4(0.0,1.0,0.0,1.0);
	}
</script>


<!-- simple texture mapped pix shader -->
<script id="shader-fullscreen-singletex-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;

	uniform float uVarOne;
	uniform vec2 uInvF;
	
	void main(void) {
		//this gives what appears to be right kind of effect.
		//changing the 1st float zooms. (larger zooms in)
		//changing the 2nd float adjusts the barrel effect (larger -ve for more effect)

		//this works but corner of texture ends up in middle of screen
		//gl_FragColor = texture2DProj(uSampler, vec3(vTextureCoord.s, vTextureCoord.t, 2.0 - 0.3*dot(vTextureCoord,vTextureCoord)));
		
		//tex2dproj divides the x and y components by z, so to offset, we should add offsetx*z, offsety*z to x,y
		gl_FragColor = texture2DProj(uSampler, vec3(1.0,1.0,2.0)*(2.0 + uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3(uInvF.s*vTextureCoord.s, uInvF.t*vTextureCoord.t, 0.0));
		
	}
</script>

<!-- vertex shader -->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;

	varying vec2 vTextureCoord;
	
	uniform float uAspect;
	uniform float uVarTwo;	//note the multiplication of uVarTwo*uAspect could be skipped by passing in uVarTwo*uAspect , uVarTwo as uniforms
	
	void main(void) {
		gl_Position = vec4(aVertexPosition, 1.0);
		vTextureCoord = vec2(aTextureCoord.s*uVarTwo*uAspect, aTextureCoord.t*uVarTwo);
	}
</script>



<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uTintColor;
	
	void main(void) {
		gl_FragColor = uTintColor*texture2D(uSampler, vTextureCoord);
	}
</script>
<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;

	void main(void) {
		gl_FragColor = uColor;
	}
</script>
<!-- vertex shader -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
			
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	}
</script>



<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>

<script type="text/javascript">
//will make a simple test scene in this project, with view to combining with code to do stereographic projection
//making a separate project initially to avoid making a mess.
//would like to split up into files better etc
//getShader, initGL should go in a utils file/function since use these all the time
//shaders themselves should go elsewhere.
//might also generalise/modularise drawable objects and put that info in separate files. 
// see http://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html

//scene should allow demonstration of circle/angle preservation. should show some spheres
//being inside a large box also useful to field of view.

//should allow player to control camera. simple way to do this? click and drag to rotate camera ? some buttons to fly forward/backward/left/right/up/down (wasd, )
//http://www.dxx-rebirth.com/frm/index.php?topic=259.0 some control examples

var shaderProgramTexmap;
var shaderProgramColored;
function initShaders(){	
	shaderProgramFullscreenTextured = loadShader( "shader-fullscreen-vs", "shader-fullscreen-singletex-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect", "uInvF"]
					});
	shaderProgramFullscreenCubemap = loadShader( "shader-fullscreen-vs", "shader-fullscreen-cube-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect"]
					});

	shaderProgramColored = loadShader( "shader-simple-vs", "shader-simple-fs",{
					attributes:["aVertexPosition"],
					uniforms:["uPMatrix","uMVMatrix","uColor"]
					});
					
	shaderProgramTexmap = loadShader( "shader-texmap-vs", "shader-texmap-fs",{
					attributes:["aVertexPosition", "aTextureCoord"],
					uniforms:["uPMatrix","uMVMatrix","uSampler","uTintColor"]
					});
}

var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var nMatrix = mat3.create();

var playerMatrix = mat4.create();
var playerCamera = mat4.create();

function setMatrixUniforms(shaderProgram) {
    gl.uniformMatrix4fv(shaderProgram.uniforms.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.uniforms.uMVMatrix, false, mvMatrix);
}



var squareVertexPositionBuffer,
	squareVertexTextureCoordBuffer,
	squareVertexIndexBuffer;

function initFullscreenBuffers() {
		//a simple quad. use indexed since this hass more in common with other 
		//webgl stuff i've written. triangle strip is maybe slightly more efficient
       
		var vertices = [
			-1,-1,0,
			-1,1,0,
			1,-1,0,
			1,1,0
		];
		var textureCoords = [
			-1,-1,
			-1,1,
			1,-1,
			1,1
		];
		
		var indices = [
			0,1,2,
			1,2,3
		]
		
		
		squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
		
		squareVertexTextureCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        squareVertexTextureCoordBuffer.itemSize = 2;
        squareVertexTextureCoordBuffer.numItems = 4;
		
		squareVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        squareVertexIndexBuffer.itemSize = 1;
        squareVertexIndexBuffer.numItems = 6;
}



var vertexPositionBuffer;
//var vertexNormalBuffer;
//var vertexTextureCoordBuffer;
var vertexIndexBuffer;

var cubeVertexPositionBuffer;
var cubeVertexTextureCoordBuffer;
var cubeVertexIndexBuffer;

function initBuffers(){
	var sphereData = makeSphereData(8,16,1.3);

	vertexPositionBuffer = gl.createBuffer();
	bufferArrayData(vertexPositionBuffer, sphereData.vertices, 3);

	var indexData = sphereData.indices;
	vertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
	vertexIndexBuffer.itemSize = 3;
	vertexIndexBuffer.numItems = indexData.length;
	
	
	//level cube. data is in data/levelCubeData.js
	cubeVertexPositionBuffer= gl.createBuffer();
	bufferArrayData(cubeVertexPositionBuffer, levelCubeData.vertices, 3);
	
	cubeVertexTextureCoordBuffer= gl.createBuffer();
	bufferArrayData(cubeVertexTextureCoordBuffer, levelCubeData.uvcoords, 2);
	
	cubeVertexIndexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(levelCubeData.indices), gl.STATIC_DRAW);
	cubeVertexIndexBuffer.itemSize = 3;
	cubeVertexIndexBuffer.numItems = levelCubeData.indices.length;
	
	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
	}
}

function setLevelTintColor(arr){
	gl.useProgram(shaderProgramTexmap);
	gl.uniform4fv(shaderProgramTexmap.uniforms.uTintColor, arr);	//set tint colour
}

function drawScene(frameTime){
	requestAnimationFrame(drawScene);
	
	//simple render direct to screen
	var rendertype = document.querySelector('input[name="rendertype"]:checked').value;
	
	if (rendertype == "straight"){
		//draw the scene straight to the screen
		setLevelTintColor([1.0,1.0,1.0,1.0]);
		
		mat4.perspective(100, gl.viewportWidth/ gl.viewportHeight, 0.1, 100, pMatrix); 
		mat4.set(playerMatrix, playerCamera);
		drawWorldScene(frameTime, 0);
	} else {
		if (rendertype == "singletex"){
		
			setLevelTintColor([0.5,1.0,0.5,1.0]);
		
			//draw the scene to offscreen framebuffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
			gl.viewport(0, 0, rttFramebuffer.width, rttFramebuffer.height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			mat4.perspective(2*(180/Math.PI)*Math.atan(rttView.fy), rttView.fx/rttView.fy, 0.1, 100, pMatrix);	//FOV set 
			mat4.set(playerMatrix, playerCamera);
			drawWorldScene(frameTime, 0);
		}else{
		
			var tints=[
				[1.0,0.4,0.4,1.0],	//red		right
				[1.0,1.0,0.4,1.0],	//yellow	left
				[0.4,1.0,0.4,1.0],	//green		up
				[0.4,1.0,1.0,1.0],	//cyan		down
				[0.4,0.4,1.0,1.0],	//blue		front
				[1.0,0.4,1.0,1.0]	//purple	rear
			];
			var rotsY=[
				0.5*Math.PI,-0.5*Math.PI,0,0,0,Math.PI
			];
			var rotsX=[
				0,0,0.5*Math.PI,-0.5*Math.PI,0,0
			];
		
		
			mat4.perspective(90.0, 1.0, 0.1, 100, pMatrix);	//FOV set 
		
			//do the same thing for cube map
			for (var ii=0;ii<6;ii++){
				setLevelTintColor(tints[ii]);
				var framebuffer = cubemapFramebuffer[ii];
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				gl.viewport(0, 0, framebuffer.width, framebuffer.height);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
				//mat4.set(playerMatrix, playerCamera);
				mat4.identity(playerCamera);
				mat4.rotateY(playerCamera, rotsY[ii]);
				mat4.rotateX(playerCamera, rotsX[ii]);
				
				mat4.multiply(playerCamera, playerMatrix, playerCamera);
				drawWorldScene(frameTime);
			}
		}
		
		//setup for drawing to screen
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		//set just drawn texture as active for drawing to screen
		gl.enableVertexAttribArray(1);
		gl.bindTexture(gl.TEXTURE_2D, rttTexture);
        //gl.generateMipmap(gl.TEXTURE_2D);
        //gl.bindTexture(gl.TEXTURE_2D, null);
		
		//draw the simple quad object to the screen

		var activeProg;
		if (rendertype == "cubemap"){
			activeProg = shaderProgramFullscreenCubemap;	//doesn't exist here yet
		} else {
			activeProg = shaderProgramFullscreenTextured;
		}
		gl.useProgram(activeProg);

		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		gl.vertexAttribPointer(activeProg.attributes.aVertexPosition, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
		gl.vertexAttribPointer(activeProg.attributes.aTextureCoord, squareVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareVertexIndexBuffer);
		
		if (rendertype == "cubemap"){
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
			gl.uniform1i(shaderProgramFullscreenCubemap.uniforms.uSampler, 0);
		}else{
			gl.activeTexture(gl.TEXTURE0);
			//gl.bindTexture(gl.TEXTURE_2D, rttTexture);
			gl.uniform1i(shaderProgramFullscreenTextured.uniforms.uSampler, 0);
		}
		var var1 = parseFloat(document.getElementById("val1range").value);
		var var2 = parseFloat(document.getElementById("val2range").value);
		gl.uniform1f(activeProg.uniforms.uVarOne, var1);
		gl.uniform1f(activeProg.uniforms.uVarTwo, var2);
		
		//calculate horizontal and vertical FOV displayed - use same maths that shaders do, using +/-1 as input.
		var maxyvert = var2;  //TODO what is this really (max value passed from fullscreen vert shader)
		var maxxvert = var2*screenAspect;
		var vfov = (360/Math.PI)*Math.atan2(maxyvert , 2.0 + var1*maxyvert*maxyvert);
		document.getElementById("vfov").innerHTML= vfov.toFixed(1);
		var hfov = (360/Math.PI)*Math.atan2(maxxvert , 2.0 + var1*maxxvert*maxxvert);
		document.getElementById("hfov").innerHTML= hfov.toFixed(1);
		
		gl.uniform1f(activeProg.uniforms.uAspect, screenAspect);
		if (rendertype == "cubemap"){
			
		}else{
			gl.uniform2fv(activeProg.uniforms.uInvF, [1.0/rttView.fx, 1.0/rttView.fy]);
			//gl.uniform2fv(activeProg.uniforms.uInvF, [1.0, 1.0]);
		}
		
		gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		
	}
}


function drawWorldScene(frameTime) {		
		//console.log("drawing...");
	
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		mat4.set(playerCamera, mvMatrix)
		mat4.rotateX(mvMatrix,Math.PI);	//turn upside down so texture looks right
		mat4.scale(mvMatrix, [10,10,10]);

		//draw level cube
		gl.useProgram(shaderProgramTexmap);
		gl.enableVertexAttribArray(1);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgramTexmap.attributes.aVertexPosition, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProgramTexmap.attributes.aTextureCoord, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms(shaderProgramTexmap);
		
		//gl.uniform4fv(shaderProgramTexmap.uniforms.uTintColor, [1.0,0.5,0.5,1.0]);	//set tint colour
		
		
		gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(shaderProgramTexmap.uniforms.uSampler, 0);
		
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);


		//draw spheres
		gl.useProgram(shaderProgramColored);
		gl.disableVertexAttribArray(1);	//need to do this since was enabled somewhere when introduced a shader than uses this (texture mapping shader) 					
										//see http://stackoverflow.com/questions/9705771/conflict-when-using-two-or-more-shaders-with-different-number-of-attributes?rq=1

		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [1.0, 0.0, 0.0, 1.0]);

		
		mat4.set(playerCamera, mvMatrix)
		
		mat4.translate(mvMatrix, [0.0, 0.0, -10]);
		
		drawSphere();
		
		
		var angStep = Math.PI/8;
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [1.0, 1.0, 0.0, 1.0]);
		mat4.set(playerCamera, mvMatrix)
		
		mat4.rotateZ(mvMatrix,Math.PI/2);
		
		drawBallRing();
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [0.0, 1.0, 0.0, 1.0]);
		mat4.set(playerCamera, mvMatrix)
		
		drawBallRing();
		
		gl.uniform4fv(shaderProgramColored.uniforms.uColor, [0.0, 0.0, 1.0, 1.0]);
		mat4.set(playerCamera, mvMatrix)
		mat4.rotateY(mvMatrix,Math.PI/2);
		drawBallRing();
		
		function drawBallRing(){
			mat4.rotateX(mvMatrix, angStep/2);
			for (var ii=0;ii<16;ii++){
				mat4.rotateX(mvMatrix, angStep);
				mat4.translate(mvMatrix, [0.0, 0.0, -10]);
				drawSphere();
				mat4.translate(mvMatrix, [0.0, 0.0, 10]);
			}
		}

}

function drawSphere(){
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgramColored.attributes.aVertexPosition, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
		
    setMatrixUniforms(shaderProgramColored);
				
    gl.drawElements(gl.TRIANGLES, vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}


//from http://learningwebgl.com/blog/?p=1786
var rttFramebuffer;
var rttTexture;

var rttView={
	fx:4,
	fy:2,
	sizeX:2048,
	sizeY:1024
};

function initTextureFramebuffer() {
	rttFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
	rttFramebuffer.width = rttView.sizeX;	//TODO 2048x1024 would work better for single texture with 16:9 final output
	rttFramebuffer.height = rttView.sizeY;

	rttTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, rttTexture);

	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	//gl.generateMipmap(gl.TEXTURE_2D);

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, rttFramebuffer.width, rttFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	var renderbuffer = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, rttFramebuffer.width, rttFramebuffer.height);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}


var cubemapFramebuffer;
var cubemapTexture;
var cubemapSize = 1024;
//cube map code from http://www.humus.name/cubemapviewer.js (slightly modified)
function initCubemapFramebuffer()
{
	cubemapFramebuffer = [];

	cubemapTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

	var faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
				 gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
				 gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
	for (var i = 0; i < faces.length; i++)
	{
		var face = faces[i];
		
		var framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		framebuffer.width = cubemapSize;
		framebuffer.height = cubemapSize;
		cubemapFramebuffer[i]=framebuffer;
		
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);	//already bound so can lose probably
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		//gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.texImage2D(face, 0, gl.RGBA, cubemapSize, cubemapSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		
		var renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, cubemapSize, cubemapSize);
		
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, face, cubemapTexture, 0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);	///???? how to connect to render buffer of cubemap? does cubemap have multiple render buffers?
	}
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);	//this gets rid of errors being logged to console.  
}


function setupScene() {
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	
	mat4.identity(playerMatrix);
}

var texture;
function initTexture() {
	texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		gl.bindTexture(gl.TEXTURE_2D, texture);
		//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	texture.image.src = "img/ash_uvgrid01.jpg";
}


function init(){

	window.addEventListener("keydown",function(evt){
		console.log("key pressed : " + evt.keyCode);
		var willPreventDefault=true;
		switch (evt.keyCode){
			case 87:				//W
				movePlayer(0.1);
				break;
			case 83:				//S
				movePlayer(-0.1);
				break;
			case 65:				//A
				movePlayerLeft(0.1);
				break;
			case 68:				//D
				movePlayerLeft(-0.1);
				break;
			case 39:
				turnPlayer(0.02);
				break;
			case 37:
				turnPlayer(-0.02);
				break;
			case 81:				//Q
				rollPlayer(-0.02);	
				break;
			case 69:				//E
				rollPlayer(0.02);	
				break;
			case 32:				//spacebar
				movePlayerUp(-0.1);
				break;
			case 17:				//ctrl
				movePlayerUp(0.1);
				break;
			default:
				willPreventDefault=false;
				break;
			case 38:
				pitchPlayer(-0.02);		//up arrow
				break;
			case 40:
				pitchPlayer(0.02);
				break;
		}
		if (willPreventDefault){evt.preventDefault()};
	})


	initGL(document.getElementById("mycanvas"));
	initTextureFramebuffer();
	initShaders();
	initTexture();
	initFullscreenBuffers();
	initCubemapFramebuffer();	//experimental!!
	initBuffers();
	gl.clearColor(0.0, 0.1, 0.1, 1.0);
    gl.enable(gl.DEPTH_TEST);
	setupScene();
	requestAnimationFrame(drawScene);
}

var playerPosition = [0,0,0];
function movePlayer(amount){	
	playerPosition[0] += amount*playerMatrix[2];
	playerPosition[1] += amount*playerMatrix[6];
	playerPosition[2] += amount*playerMatrix[10];
	setPlayerTranslation(playerPosition);
}
function movePlayerUp(amount){	
	playerPosition[0] += amount*playerMatrix[1];
	playerPosition[1] += amount*playerMatrix[5];
	playerPosition[2] += amount*playerMatrix[9];
	setPlayerTranslation(playerPosition);
}
function movePlayerLeft(amount){	
	playerPosition[0] += amount*playerMatrix[0];
	playerPosition[1] += amount*playerMatrix[4];
	playerPosition[2] += amount*playerMatrix[8];
	setPlayerTranslation(playerPosition);
}
function turnPlayer(amount){
	setPlayerTranslation([0,0,0]);

	var rotMat=mat4.create();
	mat4.identity(rotMat);
	mat4.rotateY(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);
	
	setPlayerTranslation(playerPosition);
}
function rollPlayer(amount){
	setPlayerTranslation([0,0,0]);	
	
	var rotMat=mat4.create();
	mat4.identity(rotMat);
	mat4.rotateZ(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);

	setPlayerTranslation(playerPosition);
}
function pitchPlayer(amount){
	setPlayerTranslation([0,0,0]);	
	
	var rotMat=mat4.create();
	mat4.identity(rotMat);
	mat4.rotateX(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);

	setPlayerTranslation(playerPosition);
}

function setPlayerTranslation(posArray){
	playerMatrix[12]=0;	//zero translation components
	playerMatrix[13]=0;
	playerMatrix[14]=0;
	mat4.translate(playerMatrix, posArray);
}


</script>



</head>



<body onload="init()">
<canvas id="mycanvas" width="1366" height="768">CANVAS TO GO HERE</canvas>

<br/>
<form>
  Render to texture: 
  <input type="radio" name="rendertype" value="straight" checked>Off
  <input type="radio" name="rendertype" value="singletex">Single Tex
  <input type="radio" name="rendertype" value="cubemap">Cubemap
</form> 
<input type="range" id="val1range" min="-0.25" max="0.05" value="0.0" step="0.025" name="val1">		<!-- -0.125 seems to result in stereographic projection -->
<input type="range" id="val2range" min="0.1" max="10.0" value="2.0" step="0.025" name="val1">
<br/>vfov:<span id="vfov"></span>
<br/>hfov:<span id="hfov"></span>


</body>


</html>