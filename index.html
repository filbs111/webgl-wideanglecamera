<!DOCTYPE html>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<html>

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">

<title>test scene</title>

<style>
	body {
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 20px;
		color: white;
		text-align: center;
	}
	
	#info a:link {
				color: white;
	}
		
	#info a:visited {
		color: white;
	}
</style>

<script type="text/javascript" src="lib/dat.gui.min.js"></script>
<script type="text/javascript" src="lib/stats.min.js"></script>
<script type="text/javascript" src="lib/gl-matrix-min.js"></script>
<script type="text/javascript" src="lib/multitouchsolver.js"></script>


<!-- cube mapping for FOV>180 -->
<script id="shader-fullscreen-cube-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform samplerCube uSampler;

	uniform float uVarOne;
	uniform float uVarCubeScale;
	
	void main(void) {
		
		//this works . 2 lines below equivalent. unsure which more efficient. maybe compile to same
		gl_FragColor = textureCube(uSampler, vec3(vTextureCoord.s, -vTextureCoord.t, uVarCubeScale* ( 2.0 +uVarOne*dot(vTextureCoord,vTextureCoord))  ));
		//gl_FragColor = textureCube(uSampler, vec3(0.0,0.0,1.0)*(uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3(vTextureCoord.s , vTextureCoord.t  , 2.0));
		
		//gl_FragColor = vec4(vTextureCoord.s,vTextureCoord.t,0.0,1.0);
		//gl_FragColor = vec4(0.0,1.0,0.0,1.0);
	}

</script>


<!-- simple texture mapped pix shader -->
<script id="shader-fullscreen-angled-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;

	uniform float uVarOne;
	uniform vec2 uInvF;
	
	uniform vec3 uSinCosTan;
	
	void main(void) {
		float sint = uSinCosTan.x;	//+ve for right, -ve for left
		float cost = uSinCosTan.y;
		float tan_cant_ang = uSinCosTan.z;	//+ve for rhs, -ve for lhs
		
		//this gives what appears to be right kind of effect.
		//changing the 1st float zooms. (larger zooms in)
		//changing the 2nd float adjusts the barrel effect (larger -ve for more effect)

		//this works but corner of texture ends up in middle of screen
		//gl_FragColor = texture2DProj(uSampler, vec3(vTextureCoord.s, vTextureCoord.t, 2.0 - 0.3*dot(vTextureCoord,vTextureCoord)));
		
		//tex2dproj divides the x and y components by z, so to offset, we should add offsetx*z, offsety*z to x,y
		//gl_FragColor = texture2DProj(uSampler, vec3(1.0,1.0,2.0)*(2.0 + uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3(uInvF.s*vTextureCoord.s, uInvF.t*vTextureCoord.t, 0.0));
		
		//try rotating for 45 deg plane
		
		vec3 toproject = vec3(0.0,0.0,1.0)*(2.0 + uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3( vTextureCoord.s, vTextureCoord.t, 0.0);
		//vec3 afterrotate = vec3( 0.71*(toproject.x-toproject.z) , toproject.y , 0.71*(toproject.z+toproject.x));
		//vec3 afterrotate = vec3( -2.0*toproject.z , toproject.y , 2.0*toproject.x);	// 90  deg rotation?			//seems to be centred in expected place, but too small... ?!!!
		//vec3 afterrotate = vec3( -0.5*toproject.z , toproject.y , 2.0*toproject.x);		//this ends up looking right for 90 deg. unsure why though.
		
		vec3 afterrotate = vec3( toproject.x*cost -sint*toproject.z , toproject.y , toproject.z*cost+ sint*toproject.x);	//"correct" for 45 deg.
		
		//try trivial non rotation
		//vec3 afterrotate = vec3( toproject.x , toproject.y , toproject.z);
		
		//vec3 afterrotate = vec3( toproject.x-1.0 , toproject.y , toproject.z);
		
		//gl_FragColor = texture2DProj(uSampler, vec3(0.5,0.5,0.0)*afterrotate.z +afterrotate);
		//gl_FragColor = texture2DProj(uSampler, vec3( 0.5*afterrotate.x+ 0.5*tan_cant_ang*afterrotate.z, 0.5*afterrotate.y+0.5*afterrotate.z, afterrotate.z ));	//unsure where this number comes from!
		
		gl_FragColor = texture2DProj(uSampler, vec3( uInvF.s*0.5*(afterrotate.x+ tan_cant_ang*afterrotate.z) + afterrotate.z, uInvF.t*(afterrotate.y)+afterrotate.z, 2.0*afterrotate.z));
					
	}
</script>


<!-- modify 2plane shader for 4plane -->
<script id="shader-fullscreen-4plane-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;

	uniform float uVarOne;
	uniform vec2 uInvFadjusted;
	
	uniform vec2 adjust;
	
	void main(void) {
		
		vec3 toproject = vec3(0.0,0.0,1.0)*(2.0 + uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3( vTextureCoord.s, vTextureCoord.t, 0.0);
												
		vec3 afterrotate = vec3( uInvFadjusted.x*toproject.x , uInvFadjusted.y*toproject.y, 
								toproject.z - adjust.x*toproject.x - adjust.y*toproject.y);

		gl_FragColor = texture2DProj(uSampler, vec3( 0.5*afterrotate.x + afterrotate.z,
													0.5*afterrotate.y + afterrotate.z,
													2.0*afterrotate.z));
	}
</script>


<!-- simple texture mapped pix shader -->
<script id="shader-fullscreen-singletex-fs" type="x-shader/x-fragment">
	precision mediump float;
	
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;

	uniform float uVarOne;
	uniform vec2 uInvF;
	
	void main(void) {
		//this gives what appears to be right kind of effect.
		//changing the 1st float zooms. (larger zooms in)
		//changing the 2nd float adjusts the barrel effect (larger -ve for more effect)

		//this works but corner of texture ends up in middle of screen
		//gl_FragColor = texture2DProj(uSampler, vec3(vTextureCoord.s, vTextureCoord.t, 2.0 - 0.3*dot(vTextureCoord,vTextureCoord)));
		
		//tex2dproj divides the x and y components by z, so to offset, we should add offsetx*z, offsety*z to x,y
		gl_FragColor = texture2DProj(uSampler, vec3(1.0,1.0,2.0)*(2.0 + uVarOne*dot(vTextureCoord,vTextureCoord)) + vec3(uInvF.st*vTextureCoord.st, 0.0));
		
	}
</script>

<!-- vertex shader -->
<script id="shader-fullscreen-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;

	varying vec2 vTextureCoord;
	
	uniform float uAspect;
	uniform float uVarTwo;	//note the multiplication of uVarTwo*uAspect could be skipped by passing in uVarTwo*uAspect , uVarTwo as uniforms
	
	uniform vec2 xMultShift;	//used when drawing left and right halfs of fullscreen plane separately (could just use different mesh, but very few verts so inexpensive)
								//to recover old behaviour multiply by 1 and shift by zero ie vec2(1,0, 0.0)
	uniform vec2 yMultShift;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition, 1.0);		
		vTextureCoord = vec2( (aTextureCoord.s*xMultShift.x + xMultShift.y )*uVarTwo*uAspect, (aTextureCoord.t*yMultShift.x + yMultShift.y )*uVarTwo);
	}
</script>

<!-- tex mapped pix shader -->
<script id="shader-texmap-notint-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	
	void main(void) {
		gl_FragColor = texture2D(uSampler, vTextureCoord);
	}
</script>

<!-- tex mapped pix shader -->
<script id="shader-texmap-fs" type="x-shader/x-fragment">
	precision mediump float;
	varying vec2 vTextureCoord;
	uniform sampler2D uSampler;
	uniform vec4 uTintColor;
	
	void main(void) {
		gl_FragColor = uTintColor*texture2D(uSampler, vTextureCoord);
	}
</script>
<!-- vertex shader with tex coords -->
<script id="shader-texmap-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>

<!-- simple pix shader -->
<script id="shader-simple-fs" type="x-shader/x-fragment">
	precision mediump float;
	uniform vec4 uColor;
	
	void main(void) {
		gl_FragColor = uColor;
	}
</script>
<!-- vertex shader -->
<script id="shader-simple-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
				
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	}
</script>



<!-- vertex shader with tex coords and distortion-->
<!-- won't be obvious whether works because cube so simple...-->
<script id="shader-texmap-vs-distort" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uStrengthVec;

	void main(void) {
	
		vec4 position_intermediate = uMVMatrix * vec4(aVertexPosition, 1.0);
		
		//guess want z that goes something like absolute distance (won't be correct, but...)
		vec3 squaredPosn = position_intermediate.xyz*position_intermediate.xyz;
		float mag = sqrt( dot(uStrengthVec,squaredPosn) );
		position_intermediate.z= 0.5*(position_intermediate.z - mag);
		
		gl_Position = uPMatrix * position_intermediate;
		vTextureCoord = aTextureCoord;
	}
</script>
<!-- vertex shader distort -->
<script id="shader-simple-vs-distort" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uStrengthVec;
			
	void main(void) {
	
		vec4 position_intermediate = uMVMatrix * vec4(aVertexPosition, 1.0);
		/*
		float mag = sqrt( uStrength*(position_intermediate.x*position_intermediate.x + position_intermediate.y*position_intermediate.y) + position_intermediate.z*position_intermediate.z );
		float anotherscalefactortimesmag = (mag - position_intermediate.z );
		position_intermediate.z=-0.5*anotherscalefactortimesmag;
		*/
		vec3 squaredPosn = position_intermediate.xyz*position_intermediate.xyz;
		float mag = sqrt( dot(uStrengthVec,squaredPosn) );
		position_intermediate.z= 0.5*(position_intermediate.z - mag);
		
		gl_Position = uPMatrix * position_intermediate;
	}
</script>





<script type="text/javascript" src="utils/webgl_utils.js"></script>
<script type="text/javascript" src="utils/keys.js"></script>

<script type="text/javascript" src="data/sphere.js"></script>
<script type="text/javascript" src="data/levelCubeData.js"></script>

<script type="text/javascript" src="data/wt_teapot-trimmed.obj.json"></script>
<script type="text/javascript" src="data/sship-pointyc-tidy1-uv3a.obj.json"></script>

<script type="text/javascript" src="data/guncyl.obj.json"></script>
<script type="text/javascript" src="data/sstationdark1.obj.json"></script>


<script type="text/javascript">
//will make a simple test scene in this project, with view to combining with code to do stereographic projection
//making a separate project initially to avoid making a mess.
//would like to split up into files better etc
//getShader, initGL should go in a utils file/function since use these all the time
//shaders themselves should go elsewhere.
//might also generalise/modularise drawable objects and put that info in separate files. 
// see http://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html

//scene should allow demonstration of circle/angle preservation. should show some spheres
//being inside a large box also useful to field of view.

//should allow player to control camera. simple way to do this? click and drag to rotate camera ? some buttons to fly forward/backward/left/right/up/down (wasd, )
//http://www.dxx-rebirth.com/frm/index.php?topic=259.0 some control examples

var shaderProgramTexmap,
	shaderProgramColored,
	shaderProgramTexmapDistort,
	shaderProgramColoredDistort;

var shaderProgramFullscreenTextured,
	shaderProgramFullscreenCubemap,
	shaderProgramFullscreenAngled,
	shaderProgramFullscreen4Plane;
	
function initShaders(){	
	shaderProgramFullscreenTextured = loadShader( "shader-fullscreen-vs", "shader-fullscreen-singletex-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect", "uInvF", "xMultShift", "yMultShift"]
					});
	shaderProgramFullscreenCubemap = loadShader( "shader-fullscreen-vs", "shader-fullscreen-cube-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect", "xMultShift", "yMultShift", "uVarCubeScale"]
					});
	shaderProgramFullscreenAngled = loadShader( "shader-fullscreen-vs", "shader-fullscreen-angled-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect", "uInvF", "uSinCosTan", "xMultShift", "yMultShift"]
					});
	shaderProgramFullscreen4Plane = loadShader( "shader-fullscreen-vs", "shader-fullscreen-4plane-fs",{
					attributes:["aVertexPosition","aTextureCoord"],
					uniforms:["uSampler","uVarOne","uVarTwo","uAspect", "uInvFadjusted", "adjust", "xMultShift", "yMultShift"]
					});
					
	shaderProgramColored = loadShader( "shader-simple-vs", "shader-simple-fs",{
					attributes:["aVertexPosition"],
					uniforms:["uPMatrix","uMVMatrix","uColor"]
					});
					
	shaderProgramTexmap = loadShader( "shader-texmap-vs", "shader-texmap-fs",{
					attributes:["aVertexPosition", "aTextureCoord"],
					uniforms:["uPMatrix","uMVMatrix","uSampler","uTintColor"]
					});
					
	shaderProgramColoredDistort = loadShader( "shader-simple-vs-distort", "shader-simple-fs",{
					attributes:["aVertexPosition"],
					uniforms:["uPMatrix","uMVMatrix","uColor","uStrengthVec"]
					});
					
	shaderProgramTexmapDistort = loadShader( "shader-texmap-vs-distort", "shader-texmap-notint-fs",{
					attributes:["aVertexPosition", "aTextureCoord"],
					uniforms:["uPMatrix","uMVMatrix","uSampler","uTintColor","uStrengthVec"]
					});
}

var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var nMatrix = mat3.create();

var playerMatrix = mat4.create();
var playerCamera = mat4.create();
var sshipNoseMatrix = mat4.create();
var camParams={near:0.05, far:100};

function setMatrixUniforms(shaderProgram) {
    gl.uniformMatrix4fv(shaderProgram.uniforms.uPMatrix, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.uniforms.uMVMatrix, false, mvMatrix);
}



var squareVertexPositionBuffer,
	squareVertexTextureCoordBuffer,
	squareVertexIndexBuffer;

function initFullscreenBuffers() {
		//a simple quad. use indexed since this hass more in common with other 
		//webgl stuff i've written. triangle strip is maybe slightly more efficient
       
		var vertices = [
			-1,-1,0,
			-1,1,0,
			1,-1,0,
			1,1,0
		];
		var textureCoords = [
			-1,-1,
			-1,1,
			1,-1,
			1,1
		];
		
		var indices = [
			0,1,2,
			1,3,2
		]
		
		
		squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
		
		squareVertexTextureCoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        squareVertexTextureCoordBuffer.itemSize = 2;
        squareVertexTextureCoordBuffer.numItems = 4;
		
		squareVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        squareVertexIndexBuffer.itemSize = 1;
        squareVertexIndexBuffer.numItems = 6;
}



var sphereBuffers={};
var cubeBuffers={};
var sshipBuffers={};
var gunBuffers={};
var teapotBuffers={};

function initBuffers(){
	var sphereData = makeSphereData(15,32,1);
	delete sphereData.uvcoords;	//because current shader doesn't use
	loadBufferData(sphereBuffers, sphereData);
	
	/*
	//level cube. data is in data/levelCubeData.js
	subdivideMeshData(levelCubeData);	//2x2 grid faces
	subdivideMeshData(levelCubeData);	//4x4
	subdivideMeshData(levelCubeData);	//8x8
	subdivideMeshData(levelCubeData);	//16x16
	subdivideMeshData(levelCubeData);	//32x32

	loadBufferData(cubeBuffers, levelCubeData);
*/
	var levelObject = loadBlenderExport(spacestationdata.meshes[0]);
	delete levelObject.normals;
	subdivideMeshData(levelObject);
	subdivideMeshData(levelObject);
	subdivideMeshData(levelObject);

	loadBufferData(cubeBuffers, levelObject);
	
	var sshipObject = loadBlenderExport(sshipdata.meshes[0]);
	delete sshipObject.normals;	//because current shader doesn't use
	loadBufferData(sshipBuffers, sshipObject);
	
	var gunObject = loadBlenderExport(guncyldata.meshes[0]);
	delete gunObject.normals;	//because current shader doesn't use
	loadBufferData(gunBuffers, gunObject);

	var teapotObject = loadBlenderExport(teapotData);
	delete teapotObject.normals;	//because current shader doesn't use
	loadBufferData(teapotBuffers, teapotObject);

	
	function bufferArrayData(buffer, arr, size){
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);
		buffer.itemSize = size;
		buffer.numItems = arr.length / size;
	}
	
	function loadBufferData(bufferObj, sourceData){
		bufferObj.vertexPositionBuffer = gl.createBuffer();
		bufferArrayData(bufferObj.vertexPositionBuffer, sourceData.vertices, 3);
			
		if (sourceData.uvcoords){
			bufferObj.vertexTextureCoordBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexTextureCoordBuffer, sourceData.uvcoords, 2);
		}
		
		if (sourceData.normals){
			bufferObj.vertexNormalBuffer= gl.createBuffer();
			bufferArrayData(bufferObj.vertexNormalBuffer, sourceData.normals, 3);
		}
		
		bufferObj.vertexIndexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sourceData.indices), gl.STATIC_DRAW);
		bufferObj.vertexIndexBuffer.itemSize = 3;
		bufferObj.vertexIndexBuffer.numItems = sourceData.indices.length;
	}
	
	function loadBlenderExport(meshToLoad){
		return {
			vertices: meshToLoad.vertices,
			normals: meshToLoad.normals,
			uvcoords: meshToLoad.texturecoords?meshToLoad.texturecoords[0]:false,
			indices: [].concat.apply([],meshToLoad.faces)	//trick from https://www.youtube.com/watch?v=sM9n73-HiNA t~ 28:30
		}	
	};
	
}

function setLevelTintColor(arr){
	gl.useProgram(shaderProgramTexmap);
	if (guiParams.tintViews){
		gl.uniform4fv(shaderProgramTexmap.uniforms.uTintColor, arr);	//set tint colour
	} else {
		gl.uniform4fv(shaderProgramTexmap.uniforms.uTintColor, [1.0,1.0,1.0,1.0]);
	};
}

//possibly calling glviewport slows things down.
var setGlViewportIfNecessary = (function(){
	var savedx=-1;
	var savedy=-1;
	var saveda=-1;
	var savedb=-1;
	return function(a,b,x,y){
		if (x!=savedx || y!=savedy || a!=saveda || b!=savedb){
			gl.viewport(a, b, x, y);
			saveda=a;
			savedb=b;
			savedx=x;
			savedy=y;
		}
	}
})();

function drawScene(frameTime){
	if (guiParams.resizeCanvas){resizecanvas();}

	requestAnimationFrame(drawScene);
	stats.end();
	stats.begin();
	
	if (guiParams.smoothMovement){iterateMechanics();}
	
	var var1 = parseFloat(guiParams.strength)*-0.125;
	var var2 = parseFloat(10.0/guiParams.zoom);
	
	if (guiParams.recalcParams){recalculateViewParams();}	//shouldn't be doing this every frame...
	
	
	var rendertype = guiParams.renderingMethod;
	
	var cubescale=1.0;
	if (guiParams.autoCubemapScale){
		cubescale = 5.0*(1024/1080)/guiParams.zoom;	//override cubescale - set it such that centre pixels are a constant density. 
	}									//5.0/ makes full height. other numbers here since currently using 1024x1024 cubemap faces, and aiming for 1080 high screen
										//TODO use actual screen dimensions
	
	var invcscale = 1.0/cubescale;
	
	mat4.identity(sshipNoseMatrix);
	mat4.translate(sshipNoseMatrix,[0,0,guiParams.camFwdShift]);
	mat4.multiply(sshipNoseMatrix, playerMatrix, sshipNoseMatrix);
	
	if (rendertype == "straight"){
		//draw the scene straight to the screen
		
		//use same FOV as set by the current var2, and var1 value for rectilinear (0)
		var vfov = (360/Math.PI)*Math.atan2(var2 , 2.0);
		mat4.perspective(vfov, gl.viewportWidth/ gl.viewportHeight, camParams.near, camParams.far, pMatrix); 
		
		mat4.identity(playerCamera);
		if (guiParams.rearMirror){
				mat4.scale(playerCamera, [1,1,-1]);
				gl.cullFace(gl.BACK);
		}
		mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
		
		setGlViewportIfNecessary(0, 0, gl.viewportWidth, gl.viewportHeight);
		drawWorldScene(frameTime, 0);
		
	} else {
		if (rendertype == "singletex"){
		
			setLevelTintColor([0.5,1.0,0.5,1.0]);
		
			//draw the scene to offscreen framebuffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
			setGlViewportIfNecessary(0, 0, rttFramebuffer.width, rttFramebuffer.height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			mat4.perspective(2*(180/Math.PI)*Math.atan(rttView.fy), rttView.fx/rttView.fy, camParams.near, camParams.far, pMatrix);	//FOV set 
			
			mat4.identity(playerCamera);
			if (guiParams.rearMirror){
				mat4.scale(playerCamera, [1,1,-1]);
				gl.cullFace(gl.BACK);
			}
			mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
			
			drawWorldScene(frameTime, 0);
			clearBorder();
		}else if (rendertype == "2plane"){
			setLevelTintColor([1.0,1.0,0.5,1.0]);
		
			//draw the scene to offscreen framebuffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
			setGlViewportIfNecessary(0.5*rttFramebuffer.width, 0, 0.5*rttFramebuffer.width, rttFramebuffer.height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			//mat4.perspective(90, 1.0, 0.1, 100, pMatrix);	//FOV set 
			mat4.perspective(2.0*(180.0/Math.PI)*Math.atan(biplane.fy), biplane.fx/biplane.fy, camParams.near, camParams.far, pMatrix);	//FOV set 
			
			//45 deg
			//mat4.identity(playerCamera);
			//mat4.rotateY(playerCamera, Math.PI/4);
			//mat4.multiply(playerCamera, playerMatrix, playerCamera);
			
			
			//pMatrix[8]=-2;	//shift centre of perspective by 1 texture width
			
			mat4.identity(playerCamera);

			var tan_cant_ang=biplane.tan_cant_ang;
			
			mat4.rotateY(playerCamera, Math.atan(tan_cant_ang));
			
			if (guiParams.rearMirror){
				mat4.scale(playerCamera, [1,1,-1]);
				gl.cullFace(gl.BACK);
			}
			mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
			
			pMatrix[8]=1.0-tan_cant_ang/biplane.fx;
			
			drawWorldScene(frameTime, 0);
			
			
			//draw left hand side
			//draw the scene to offscreen framebuffer
			setLevelTintColor([0.5,1.0,1.0,1.0]);
			
			//gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
			setGlViewportIfNecessary(0, 0, 0.5*rttFramebuffer.width, rttFramebuffer.height);
			mat4.perspective(2.0*(180.0/Math.PI)*Math.atan(biplane.fy), biplane.fx/biplane.fy, camParams.near, camParams.far, pMatrix);	//FOV set 
	
			mat4.identity(playerCamera);

			mat4.rotateY(playerCamera, -Math.atan(tan_cant_ang));
			
			if (guiParams.rearMirror){
				mat4.scale(playerCamera, [1,1,-1]);	//TODO premultiply sshipnosematrix by [1,1,-1] somehow for effectively sship rear camera
			}
			mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
			
			pMatrix[8]=-1.0+tan_cant_ang/biplane.fx;
			
			drawWorldScene(frameTime, 0);
			clearBorder();
		}else if (rendertype == "4plane"){
		
		
			//draw the scene to offscreen framebuffer
			gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
			
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			mat4.perspective(2*(180/Math.PI)*Math.atan(quadplane.fy), quadplane.fx/quadplane.fy , camParams.near, camParams.far, pMatrix);	//FOV set
			
			//draw bottom left quadrant first.
			setGlViewportIfNecessary(0, 0, 0.5*rttFramebuffer.width, 0.5*rttFramebuffer.height);
			setLevelTintColor([1.0,1.0,1.0,1.0]);
			
			mat4.identity(playerCamera);
			if (guiParams.rearMirror){
				mat4.scale(playerCamera, [1,1,-1]);
				gl.cullFace(gl.BACK);
			}
			mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
			

			//shift centre of perspective 
			pMatrix[8]=-1;
			pMatrix[9]=-1;
			
			var yadjust=-quadplane.yadjust;
			//var xadjust=-0.9;
			var xadjust=-quadplane.xadjust;	//keep the same for now so don't need to pass multiple values thru to shader
			
			//this makes some perspective transform where bottom of pic wider than top, but appears to affect depth (afaik affects output w)
			//so guess should adjust in conjunction with things that affect z output
			pMatrix[7] = yadjust;		//affects w output as func of y input
			pMatrix[6] = yadjust;		//affects z output as func of y input
			//a bit of shear appears to cure that...
			pMatrix[4]= yadjust;
			
			//then do the equivalent for x (instead of y)
			pMatrix[3] = xadjust;
			pMatrix[2] = xadjust;
			pMatrix[1] = xadjust;
			
			//and that looks about right! next trick: work out what values to use to frame just enough to cover some given
			//stereographic projection on screen...
			//and does z make sense
			
			//mat4.set(playerMatrix, playerCamera);
			drawWorldScene(frameTime, 0);
			
			//draw other quadrants in similar fashion.
			//top left
			setGlViewportIfNecessary(0, 0.5*rttFramebuffer.height, 0.5*rttFramebuffer.width, 0.5*rttFramebuffer.height);
			setLevelTintColor([0.5,0.5,0.5,1.0]);

			pMatrix[9]=1;
			pMatrix[7] = -yadjust;
			pMatrix[6] = -yadjust;
			pMatrix[4]=  -yadjust;

			pMatrix[1] = -xadjust;
			
			drawWorldScene(frameTime, 0);
			
			//top right
			setGlViewportIfNecessary(0.5*rttFramebuffer.width, 0.5*rttFramebuffer.height, 0.5*rttFramebuffer.width, 0.5*rttFramebuffer.height);
			setLevelTintColor([1.0,1.0,1.0,1.0]);

			pMatrix[8]=1;
			pMatrix[3] = -xadjust;
			pMatrix[2] = -xadjust;
			pMatrix[1]=  xadjust;

			pMatrix[4] = yadjust;
			
			drawWorldScene(frameTime, 0);
			
			//bottom right
			setGlViewportIfNecessary(0.5*rttFramebuffer.width, 0, 0.5*rttFramebuffer.width, 0.5*rttFramebuffer.height);
			setLevelTintColor([0.5,0.5,0.5,1.0]);
			
			pMatrix[9]=-1;
			pMatrix[7] = yadjust;
			pMatrix[6] = yadjust;
			pMatrix[4] = -yadjust;
			
			pMatrix[1]=  -xadjust;
		
			drawWorldScene(frameTime, 0);
		
			clearBorder();
		}else{
		
			var tints=[
				[1.0,0.4,0.4,1.0],	//red		right
				[1.0,1.0,0.4,1.0],	//yellow	left
				[0.4,1.0,0.4,1.0],	//green		up
				[0.4,1.0,1.0,1.0],	//cyan		down
				[0.4,0.4,1.0,1.0],	//blue		front
				[1.0,0.4,1.0,1.0]	//purple	rear
			];
			var rotsY=[
				0.5*Math.PI,-0.5*Math.PI,0,0,0,Math.PI
			];
			var rotsX=[
				0,0,0.5*Math.PI,-0.5*Math.PI,0,0
			];
		
			//mat4.perspective(90.0, 1.0, 0.1, 100, pMatrix);	//FOV set 
			
			var fxfy = [
				{x:1,y:invcscale},
				{x:1,y:invcscale},
				{x:invcscale,y:1},
				{x:invcscale,y:1},
				{x:cubescale,y:cubescale},
				{x:cubescale,y:cubescale},
			]
			
			if (guiParams.rearMirror){
				gl.cullFace(gl.BACK);
			}
			
			//do the same thing for cube map
			for (var ii=0;ii<6;ii++){
				//stretched cubemap. TODO precalc these, since using mat4.perspective is inefficient/ugly!
				var thisfxfy = fxfy[ii];
				
				mat4.perspective( (360.0/Math.PI)*Math.atan(thisfxfy.x), thisfxfy.y/thisfxfy.x, camParams.near, camParams.far, pMatrix);
			
				setLevelTintColor(tints[ii]);
				var framebuffer = cubemapFramebuffer[ii];
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				setGlViewportIfNecessary(0, 0, framebuffer.width, framebuffer.height);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
				//mat4.set(playerMatrix, playerCamera);
				mat4.identity(playerCamera);
				
				mat4.rotateY(playerCamera, rotsY[ii]);
				mat4.rotateX(playerCamera, rotsX[ii]);
				
				if (guiParams.rearMirror){
					mat4.scale(playerCamera, [1,1,-1]);
				}
				
				mat4.multiply(playerCamera, sshipNoseMatrix, playerCamera);
								
				drawWorldScene(frameTime);
			}
			
			
		}
		//set back to normal behaviour
		gl.cullFace(gl.FRONT);
		
		//setup for drawing to screen
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		setGlViewportIfNecessary(0, 0, gl.viewportWidth, gl.viewportHeight);
		
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		//set just drawn texture as active for drawing to screen
		gl.enableVertexAttribArray(1);
		gl.bindTexture(gl.TEXTURE_2D, rttTexture);
        //gl.generateMipmap(gl.TEXTURE_2D);
        //gl.bindTexture(gl.TEXTURE_2D, null);
		
		//draw the simple quad object to the screen

		var activeProg;
		if (rendertype == "cubemap"){
			activeProg = shaderProgramFullscreenCubemap;	//doesn't exist here yet
		} else if (rendertype == "2plane"){
			activeProg = shaderProgramFullscreenAngled;
		} else if (rendertype == "4plane"){
			activeProg = shaderProgramFullscreen4Plane;
		} else {
			activeProg = shaderProgramFullscreenTextured;
		}
		gl.useProgram(activeProg);

		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
		gl.vertexAttribPointer(activeProg.attributes.aVertexPosition, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
		gl.vertexAttribPointer(activeProg.attributes.aTextureCoord, squareVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, squareVertexIndexBuffer);
		
		if (rendertype == "cubemap"){
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
			gl.uniform1i(shaderProgramFullscreenCubemap.uniforms.uSampler, 0);
		}else{
			gl.activeTexture(gl.TEXTURE0);
			//gl.bindTexture(gl.TEXTURE_2D, rttTexture);
			gl.uniform1i(activeProg.uniforms.uSampler, 0);
		}
		
		gl.uniform1f(activeProg.uniforms.uVarOne, var1);
		gl.uniform1f(activeProg.uniforms.uVarTwo, var2);
		
		gl.uniform1f(activeProg.uniforms.uAspect, screenAspect);
		if (rendertype == "cubemap"){
			gl.uniform2fv(activeProg.uniforms.xMultShift, [1.0, 0.0]);
			gl.uniform2fv(activeProg.uniforms.yMultShift, [1.0, 0.0]);
			gl.uniform1f(activeProg.uniforms.uVarCubeScale, cubescale);
		}else if (rendertype == "2plane"){
			gl.uniform2fv(activeProg.uniforms.uInvF, [1.0/biplane.fx, 1.0/biplane.fy]);
			gl.uniform2fv(activeProg.uniforms.xMultShift, [0.5, -0.5]);
			gl.uniform2fv(activeProg.uniforms.yMultShift, [1.0, 0.0]);
			
			var ang = Math.atan(tan_cant_ang);
			gl.uniform3fv(activeProg.uniforms.uSinCosTan, [-Math.sin(ang), Math.cos(ang), -tan_cant_ang ]);
			setGlViewportIfNecessary(0, 0, gl.viewportWidth/2, gl.viewportHeight);					//LHS
			gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			
			gl.uniform2fv(activeProg.uniforms.xMultShift, [0.5, 0.5]);
			gl.uniform3fv(activeProg.uniforms.uSinCosTan, [Math.sin(ang), Math.cos(ang), tan_cant_ang ]);
			setGlViewportIfNecessary(gl.viewportWidth/2, 0, gl.viewportWidth/2, gl.viewportHeight);	//RHS
		}else if (rendertype == "4plane"){
			//create vertex buffer of 4 canted planes - ie 9 vertices - index buffer will not change
			//take advantage of standard perspective texturing instead of tex2dproj (not sure if that affects speed)
			//the vertex positions that end up on screen will be constant (4 corners, edge midpoints, middle of screen)
			// - but don't pass these in. pass in x,y,w such that x/w, y/w result in the correct screen space co-ords
			//and such that the nature of homogenous co-ordinates result in x,y as would be ..
			
			
			//maybe there is some cunning optimisation 
			//but for now - do similar way to 2plane rendering - ie draw 4 viewports, and have probably more calculation than is necessary in the frag shader
			
			gl.uniform2fv(activeProg.uniforms.uInvFadjusted, [1.0/quadplane.fx + quadplane.xadjust, 1.0/quadplane.fy + quadplane.yadjust]);		//bottom left
			gl.uniform2fv(activeProg.uniforms.xMultShift, [0.5, -0.5]);
			gl.uniform2fv(activeProg.uniforms.yMultShift, [0.5, -0.5]);
			gl.uniform2fv(activeProg.uniforms.adjust, [quadplane.xadjust, quadplane.yadjust ]);
			setGlViewportIfNecessary(0, 0, gl.viewportWidth/2, gl.viewportHeight/2);
			gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			
			gl.uniform2fv(activeProg.uniforms.uInvFadjusted, [1.0/quadplane.fx + quadplane.xadjust, 1.0/quadplane.fy + quadplane.yadjust]);		//top left
			gl.uniform2fv(activeProg.uniforms.yMultShift, [0.5, 0.5]);
			gl.uniform2fv(activeProg.uniforms.adjust, [quadplane.xadjust, -quadplane.yadjust ]);
			setGlViewportIfNecessary(0, gl.viewportHeight/2, gl.viewportWidth/2, gl.viewportHeight/2);
			gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

			gl.uniform2fv(activeProg.uniforms.uInvFadjusted, [1.0/quadplane.fx + quadplane.xadjust, 1.0/quadplane.fy + quadplane.yadjust]);		//top right
			gl.uniform2fv(activeProg.uniforms.xMultShift, [0.5, 0.5]);
			gl.uniform2fv(activeProg.uniforms.adjust, [-quadplane.xadjust, -quadplane.yadjust ]);
			setGlViewportIfNecessary(gl.viewportWidth/2, gl.viewportHeight/2, gl.viewportWidth/2, gl.viewportHeight/2);
			gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			
			gl.uniform2fv(activeProg.uniforms.uInvFadjusted, [1.0/quadplane.fx + quadplane.xadjust, 1.0/quadplane.fy + quadplane.yadjust]);		//bottom right
			gl.uniform2fv(activeProg.uniforms.yMultShift, [0.5, -0.5]);
			gl.uniform2fv(activeProg.uniforms.adjust, [-quadplane.xadjust, quadplane.yadjust ]);
			setGlViewportIfNecessary(gl.viewportWidth/2, 0, gl.viewportWidth/2, gl.viewportHeight/2);
		}else{
			gl.uniform2fv(activeProg.uniforms.uInvF, [1.0/rttView.fx, 1.0/rttView.fy]);
			//gl.uniform2fv(activeProg.uniforms.uInvF, [1.0, 1.0]);
			gl.uniform2fv(activeProg.uniforms.xMultShift, [1.0, 0.0]);
			gl.uniform2fv(activeProg.uniforms.yMultShift, [1.0, 0.0]);
		}
		
		gl.drawElements(gl.TRIANGLES, squareVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	}
	
	//calculate horizontal and vertical FOV displayed - use same maths that shaders do, using +/-1 as input.
	var maxyvert = var2;
	var maxxvert = var2*screenAspect;
	var vfov = (360/Math.PI)*Math.atan2(maxyvert , 2.0 + var1*maxyvert*maxyvert);
	
	var hfov = (360/Math.PI)*Math.atan2(maxxvert , 2.0 + var1*maxxvert*maxxvert);

	if (guiParams.updateGui){
		guiParams.vFOV = vfov.toFixed(1);
		guiParams.hFOV = hfov.toFixed(1);
	}
	//console.log("hfov calculation - maxxvert = " + maxxvert + "var1 = " + var1 + ", screenAspect = " + screenAspect );
	
	
	function clearBorder(){
		//draw a border so clearer where extent of correct reprojection is.
		//if wanted to do this more efficiently, would just change viewport when rendering views
		//but this is only intended as a testing tool - for performance testing, should disable
		if (!guiParams.clearBorders){return;}
		gl.enable(gl.SCISSOR_TEST);
		gl.scissor(0, 0, 1, rttFramebuffer.height);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.scissor(0, 0, rttFramebuffer.width, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.scissor(rttFramebuffer.width-1, 0, 1, rttFramebuffer.height);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.scissor(0, rttFramebuffer.height-1, rttFramebuffer.width, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.disable(gl.SCISSOR_TEST);
	}
}


var gunRot=0;

function drawWorldScene(frameTime) {		
		//console.log("drawing...");
		var activeProg;
	
		var invertedPlayerMatrix = mat4.create();
		mat4.set(playerMatrix, invertedPlayerMatrix);
		mat4.inverse(invertedPlayerMatrix);
	
		mat4.set(playerCamera, mvMatrix)
		mat4.rotateX(mvMatrix,Math.PI);	//turn upside down so texture looks right
		//mat4.scale(mvMatrix, [10,10,10]);
		mat4.scale(mvMatrix, [10,10,-10]);

		
		if (guiParams.drawBox){
		
			//draw level cube
			if (guiParams.renderingMethod == 'straight'){
				activeProg=shaderProgramTexmapDistort;
			}else{
				activeProg=shaderProgramTexmap;
			};
			gl.useProgram(activeProg);
			
			gl.bindTexture(gl.TEXTURE_2D, levelTexture.texture);
			
			if (guiParams.renderingMethod == 'straight'){
				var str = parseFloat(guiParams.strength);
				gl.uniform3fv(shaderProgramTexmapDistort.uniforms.uStrengthVec, [str,str,1]);
			}
			
			
			gl.enableVertexAttribArray(1);
						
			drawObjectFromBuffers(cubeBuffers, activeProg);

		}

		if (guiParams.drawBalls){
			//draw spheres
			if (guiParams.renderingMethod == 'straight'){
				activeProg=shaderProgramColoredDistort;
			}else{
				activeProg=shaderProgramColored;
			};
			gl.useProgram(activeProg);
			
			if (guiParams.renderingMethod == 'straight'){
				var str = parseFloat(guiParams.strength);
				gl.uniform3fv(shaderProgramColoredDistort.uniforms.uStrengthVec, [str,str,1]);
			}
			
			gl.disableVertexAttribArray(1);	//need to do this since was enabled somewhere when introduced a shader than uses this (texture mapping shader) 					
											//see http://stackoverflow.com/questions/9705771/conflict-when-using-two-or-more-shaders-with-different-number-of-attributes?rq=1

			gl.uniform4fv(activeProg.uniforms.uColor, [1.0, 0.0, 0.0, 1.0]);

			
			mat4.set(playerCamera, mvMatrix)
			
			mat4.translate(mvMatrix, [0.0, 0.0, -10]);
			/*
			drawObjectFromBuffers(sphereBuffers, activeProg);
			
			var angStep = Math.PI/8;
			
			gl.uniform4fv(activeProg.uniforms.uColor, [1.0, 1.0, 0.0, 1.0]);
			mat4.set(playerCamera, mvMatrix)
			
			mat4.rotateZ(mvMatrix,Math.PI/2);
			
			drawBallRing();
			
			gl.uniform4fv(activeProg.uniforms.uColor, [0.0, 1.0, 0.0, 1.0]);
			mat4.set(playerCamera, mvMatrix)
			
			drawBallRing();
			
			gl.uniform4fv(activeProg.uniforms.uColor, [0.0, 0.0, 1.0, 1.0]);
			mat4.set(playerCamera, mvMatrix)
			mat4.rotateY(mvMatrix,Math.PI/2);
			drawBallRing();
			*/
			//draw a ball to show nosecam
			mat4.set(playerCamera, mvMatrix)
			mat4.scale(mvMatrix, [0.01, 0.01, 0.01]);
			mat4.translate(mvMatrix, [0.0, 0.0, -100*guiParams.camFwdShift]);
			gl.uniform4fv(activeProg.uniforms.uColor, [0.9, 0.1, 0.1, 1.0]);
			drawObjectFromBuffers(sphereBuffers, activeProg);
			
			
			var savedShader = activeProg;
			if (guiParams.renderingMethod == 'straight'){
				activeProg=shaderProgramTexmapDistort;
			}else{
				activeProg=shaderProgramTexmap;
			};
			gl.useProgram(activeProg);
			
			gl.bindTexture(gl.TEXTURE_2D, sshipTexture.texture);

			mat4.set(playerCamera, mvMatrix);
			if (!guiParams.dropSpaceship){
				mat4.multiply(mvMatrix, invertedPlayerMatrix);	//this SHOULD get the identity matrix (this works in 3sphere proj, but perhaps not here...)
			}
			//mat4.translate(mvMatrix, [0.0, 0.0, guiParams.camFwdShift]);
			mat4.scale(mvMatrix, [-0.01, 0.01, 0.01]);
			gl.enableVertexAttribArray(1);

			drawObjectFromBuffers(sshipBuffers, activeProg);
			
			activeProg=savedShader;
			gl.useProgram(activeProg);
			gl.disableVertexAttribArray(1);

			
			//draw a "gun object"
			var gunHoriz = 0.2;	//note different values to 3sphere project. TODO standardise method of multiplying matrices, positioning stuff in world etc
			var gunVert = 0.1;
			var gunFront = -0.1;
			
			var gunMatrix = mat4.create();
			var saveMatrix = mat4.create();
			if (!guiParams.dropSpaceship){
				mat4.set(invertedPlayerMatrix,saveMatrix);
			}else{
				mat4.identity(saveMatrix);
			}
			
			var gunOffsets = [[gunHoriz,gunVert,gunFront],
								[-gunHoriz,gunVert,gunFront],
								[gunHoriz,-gunVert,gunFront],
								[-gunHoriz,-gunVert,gunFront]];
			
			gunOffsets.forEach(function(offset){
				mat4.set(saveMatrix, gunMatrix);
				mat4.translate(gunMatrix, offset);
				mat4.rotateY(gunMatrix, gunRot);
				mat4.translate(gunMatrix, [0,0,-0.2]);

				mat4.set(playerCamera, mvMatrix);
				mat4.multiply(mvMatrix, gunMatrix);	//this SHOULD get the identity matrix (this works in 3sphere proj, but perhaps not here...)
				mat4.scale(mvMatrix, [0.5, 0.5, 0.5]);
				gl.uniform4fv(activeProg.uniforms.uColor, [0.3, 0.3, 0.3, 1.0]);
				drawObjectFromBuffers(gunBuffers, activeProg);
			});
			/*
			//draw teapot
			mat4.set(playerCamera, mvMatrix)
			mat4.translate(mvMatrix, [0.0, -0.5, -2]);
			gl.uniform4fv(activeProg.uniforms.uColor, [0.4, 0.3, 0.2, 1.0]);
			drawObjectFromBuffers(teapotBuffers, activeProg);
			*/
			
		}
		
		function drawBallRing(){
			mat4.rotateX(mvMatrix, angStep/2);
			for (var ii=0;ii<16;ii++){
				mat4.rotateX(mvMatrix, angStep);
				mat4.translate(mvMatrix, [0.0, 0.0, -10]);
				drawObjectFromPreppedBuffers(sphereBuffers, activeProg);
				mat4.translate(mvMatrix, [0.0, 0.0, 10]);
			}
		}

}


function drawObjectFromBuffers(bufferObj, shaderProg){
	prepBuffersForDrawing(bufferObj, shaderProg);
	drawObjectFromPreppedBuffers(bufferObj, shaderProg);
}
function prepBuffersForDrawing(bufferObj, shaderProg){
	gl.enable(gl.CULL_FACE);
	gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexPositionBuffer);
    gl.vertexAttribPointer(shaderProg.attributes.aVertexPosition, bufferObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	if (bufferObj.vertexNormalBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexNormalBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aVertexNormal, bufferObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	}
	
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferObj.vertexIndexBuffer);
	
	if (bufferObj.vertexTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, bufferObj.vertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProg.attributes.aTextureCoord, bufferObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
		gl.activeTexture(gl.TEXTURE0);
		gl.uniform1i(shaderProg.uniforms.uSampler, 0);
	}
	gl.uniformMatrix4fv(shaderProg.uniforms.uPMatrix, false, pMatrix);
}
function drawObjectFromPreppedBuffers(bufferObj, shaderProg){
	gl.uniformMatrix4fv(shaderProg.uniforms.uMVMatrix, false, mvMatrix);
	gl.drawElements(gl.TRIANGLES, bufferObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
}


//from http://learningwebgl.com/blog/?p=1786
var rttFramebuffer;
var rttTexture;

var rttView={
	fx:2,
	fy:1,
	sizeX:2048,
	sizeY:1024
};

var biplane={
	fx:2.5,
	fy:2.5,
	tan_cant_ang:0.55	//setting all of these variables dynamically now to suit screen zoom, aspect now, so irrelevant
};

var quadplane={
	fx:5,
	fy:0.9,
	xadjust:0.6,
	yadjust:0.35	//setting all of these variables dynamically now to suit screen zoom, aspect now, so irrelevant
};

function initTextureFramebuffer() {
	rttFramebuffer = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
	rttFramebuffer.width = rttView.sizeX;	//TODO 2048x1024 would work better for single texture with 16:9 final output
	rttFramebuffer.height = rttView.sizeY;

	rttTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, rttTexture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

	//gl.generateMipmap(gl.TEXTURE_2D);

	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, rttFramebuffer.width, rttFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	var renderbuffer = gl.createRenderbuffer();
	gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
	gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, rttFramebuffer.width, rttFramebuffer.height);

	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);
	gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

	gl.bindTexture(gl.TEXTURE_2D, null);
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}


var cubemapFramebuffer;
var cubemapTexture;
var cubemapSize = 1024;
//cube map code from http://www.humus.name/cubemapviewer.js (slightly modified)
function initCubemapFramebuffer()
{
	cubemapFramebuffer = [];

	cubemapTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

	var faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
				 gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
				 gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
				 gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
	for (var i = 0; i < faces.length; i++)
	{
		var face = faces[i];
		
		var framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
		framebuffer.width = cubemapSize;
		framebuffer.height = cubemapSize;
		cubemapFramebuffer[i]=framebuffer;
		
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);	//already bound so can lose probably
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		//gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
		gl.texImage2D(face, 0, gl.RGBA, cubemapSize, cubemapSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		
		var renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, cubemapSize, cubemapSize);
		
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, face, cubemapTexture, 0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
	}
	gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);	//this gets rid of errors being logged to console. 
	gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}


function setupScene() {
	setGlViewportIfNecessary(0, 0, gl.viewportWidth, gl.viewportHeight);
	
	mat4.identity(playerMatrix);
}

var levelTexture={};
var sshipTexture={};

function initTexture(textureContainer, src) {
	var texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		gl.bindTexture(gl.TEXTURE_2D, texture);
		//gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	texture.image.src = src;
	textureContainer.texture = texture;
}

var stats;
var gui;
var pointerLocked=false;
var guiParams={
	updateGui: true,
	pixSizeMultiplier:1.0,
	strength:1.0,
	zoom:2.5,
	renderingMethod:null,
	hFOV:"",
	vFOV:"",
	autoCubemapScale:true,
	tintViews: false,
	clearBorders: true,
	indentViews: false,
	drawBox: true,
	drawBalls: true,
	dropSpaceship: true,
	camFwdShift: 0.5,
	resizeCanvas: true,
	recalcParams: true,
	keepInsideBox: false,
	smoothMovement: true,
	rearMirror:false,
	lockPointer:function(){
		canvas.requestPointerLock();
		gui.close();
		}
};
var mouseInfo = {
	x:0,
	y:0,
	dragging: false,
	lastPointingDir:{}
};

function init(){

	stats = new Stats();
	stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
	document.body.appendChild( stats.dom );
	
	gui = new dat.GUI();
	gui.add(guiParams, 'updateGui');
	gui.add(guiParams, 'pixSizeMultiplier', 0.25, 4.0, 0.25).listen();
	gui.add(guiParams, 'strength', -0.2, 1.5, 0.1).listen();
	gui.add(guiParams, 'zoom', 1, 10, 0.01).listen();
	
	//note the counterintuitive order or key:value here ( the key is the displayed string, the value )
	var renderingMethodOptions = {
		'direct to screen (no reprojection)':'straight',
		'single plane view': 'singletex',
		'biplanar (2 views)' : '2plane',
		'quadplane (4 views)': '4plane',
		'cubemap (6 views)': 'cubemap'} 
	guiParams.renderingMethod = 'cubemap';
	gui.add(guiParams, 'renderingMethod', renderingMethodOptions ).listen().onFinishChange(function(){
		this.domElement.children[0].blur();
	});	//hack to try to prevent arrow keys changing dropdown after selected something
	gui.add(guiParams, 'autoCubemapScale');
	
	//just using these for display. TODO allow modification by user dragging/typing (requires calculation of zoom, and can only approach 180 deg for zero "strength", less for -ve
	var elem;	//http://stackoverflow.com/questions/24461964/method-for-disabling-a-button-in-dat-gui
	elem = gui.add(guiParams, 'hFOV' ).listen().onChange(function(hFOV){
		//simplify things by forcing "strength" to some barrel distortion (0 is flat, 1 is stereographic)
		if (guiParams.strength<0.1){guiParams.strength = 0.1};
		hFOV = parseFloat(hFOV);
		hFOV = Math.min(hFOV,359);
		hFOV = Math.max(hFOV,30);
		
		var wantedTan = Math.tan(hFOV*Math.PI/360.0);
		var var1 = parseFloat(guiParams.strength)*-0.125;
		var something = Math.sqrt(1.0-8.0*wantedTan*wantedTan*var1);
		var hackAbs = (wantedTan>0)? 1:-1;	//this is horrible and can probably be refactored into something much nicer. unimportant
		
		guiParams.zoom = 10.0*screenAspect/( (0.5/(wantedTan*var1))*(1.0 - hackAbs*something ));
	});
	elem = gui.add(guiParams, 'vFOV' ).listen().onChange(function(vFOV){
		//simplify things by forcing "strength" to some barrel distortion (0 is flat, 1 is stereographic)
		if (guiParams.strength<0.1){guiParams.strength = 0.1};
		vFOV = parseFloat(vFOV);
		vFOV = Math.min(vFOV,359);
		vFOV = Math.max(vFOV,1);
		
		var wantedTan = Math.tan(vFOV*Math.PI/360.0);
		var var1 = parseFloat(guiParams.strength)*-0.125;
		var something = Math.sqrt(1.0-8.0*wantedTan*wantedTan*var1);
		var hackAbs = (wantedTan>0)? 1:-1;	//this is horrible and can probably be refactored into something much nicer. unimportant
		
		guiParams.zoom = 10.0/( (0.5/(wantedTan*var1))*(1.0 - hackAbs*something ));
	});
	
	gui.add(guiParams, 'tintViews');
	gui.add(guiParams, 'clearBorders');
	gui.add(guiParams, 'indentViews');
	gui.add(guiParams, 'drawBox');
	gui.add(guiParams, 'drawBalls');
	gui.add(guiParams, 'dropSpaceship');
	gui.add(guiParams, 'camFwdShift',-0.6,0.6,0.05);
	gui.add(guiParams, 'resizeCanvas');
	gui.add(guiParams, 'recalcParams');
	gui.add(guiParams, 'rearMirror');

	var movementFolder = gui.addFolder('movement');
	movementFolder.add(guiParams, 'keepInsideBox');
	movementFolder.add(guiParams, 'lockPointer');
	movementFolder.add(guiParams, 'smoothMovement');
	
	keyThing.setKeydownCallback(70,function(){			//70=F
		goFullscreen(canvas);
	});
	
	window.addEventListener("keydown",function(evt){
		console.log("key pressed : " + evt.keyCode);
		var willPreventDefault=true;
		var controlSpeed = guiParams.smoothMovement ? 0:0.1;
		switch (evt.keyCode){
			case 87:				//W
				movePlayer([0,0,controlSpeed]);
				break;
			case 83:				//S
				movePlayer([0,0,-controlSpeed]);
				break;
			case 65:				//A
				movePlayer([controlSpeed,0,0]);
				break;
			case 68:				//D
				movePlayer([-controlSpeed,0,0]);
				break;
			case 39:
				turnPlayer(controlSpeed);
				break;
			case 37:
				turnPlayer(-controlSpeed);
				break;
			case 81:				//Q
				rollPlayer(-controlSpeed);	
				break;
			case 69:				//E
				rollPlayer(controlSpeed);	
				break;
			case 32:				//spacebar
				movePlayer([0,-controlSpeed,0]);
				break;
			case 17:				//ctrl
				movePlayer([0,controlSpeed,0]);
				break;
			default:
				willPreventDefault=false;
				break;
			case 38:
				pitchPlayer(-controlSpeed);		//up arrow
				break;
			case 40:
				pitchPlayer(controlSpeed);
				break;
		}
		constrainPlayerPositionToBox();
		if (willPreventDefault){evt.preventDefault()};
	})
	
	canvas = document.getElementById("mycanvas");
	canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
	
	document.addEventListener('pointerlockchange', lockChangeAlert, false);
	document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

	function lockChangeAlert() {
	  if (document.pointerLockElement === canvas ||
		  document.mozPointerLockElement === canvas) {
			console.log('The pointer lock status is now locked');
			pointerLocked=true;
		} else {
			console.log('The pointer lock status is now unlocked');  
			pointerLocked=false;
	  }
	}
	
	
	canvas.addEventListener("mousedown", function(evt){
		mouseInfo.x = evt.offsetX;
		mouseInfo.y = evt.offsetY;
		mouseInfo.dragging = true;
		mouseInfo.lastPointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
	});
	canvas.addEventListener("mouseup", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mouseout", function(evt){
		mouseInfo.dragging = false;
	});
	canvas.addEventListener("mousemove", function(evt){
		if (mouseInfo.dragging){
			console.log("evt offsetX = " + evt.offsetX + ", offsetY = " + evt.offsetY);
			console.log("moved : " + evt.movementX + ", movementY = " + evt.movementY);	//this is very nearly the same as the calculated version
			console.log("calculated moved : " + (evt.offsetX - mouseInfo.x) + ", movementY = " + (evt.offsetY - mouseInfo.y) );
			mouseInfo.x = evt.offsetX;
			mouseInfo.y = evt.offsetY;
			
			var pointingDir = getPointingDirectionFromScreenCoordinate({x:mouseInfo.x, y: mouseInfo.y});
			console.log("pointingDir = " + pointingDir);
			
			//get the direction of current and previous mouse position.
			//do a cross product to work out the angle rotated
			//and rotate the player by this amount
			
			var crossProd = crossProductHomgenous(pointingDir, mouseInfo.lastPointingDir);
			mouseInfo.lastPointingDir = pointingDir;
			
			//rotate player 
			rotatePlayer([ -crossProd.x / crossProd.w, crossProd.y / crossProd.w, crossProd.z / crossProd.w]);
		}
		
		if (pointerLocked){
			rotatePlayer([ 0.001* evt.movementY, 0.001* evt.movementX, 0]);	//TODO screen resolution dependent sensitivity.
		}
	});
	
	canvas.addEventListener("touchstart", handleTouchStart, false);
	canvas.addEventListener("touchend", handleTouchEnd, false);
	canvas.addEventListener("touchmove", handleTouchMove, false);
	
	initGL();
	initTextureFramebuffer();
	initShaders();
	//initTexture(levelTexture, "img/ash_uvgrid01.jpg");
	initTexture(levelTexture, "data/sstatdark1margin.png");
	initTexture(sshipTexture, "data/sship1dark.png");
	initFullscreenBuffers();
	initCubemapFramebuffer();	//experimental!!
	initBuffers();
	gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.FRONT);
	setupScene();
	requestAnimationFrame(drawScene);
}

var iterateMechanics = (function iterateMechanics(){
	var lastTime=(new Date()).getTime();
	var moveSpeed=0.01;
	var rotateSpeed=0.002;

	return function(){
		var nowTime = (new Date()).getTime();
		var timeElapsed = Math.min(nowTime - lastTime, 50);	//ms. 50ms -> slowdown if drop below 20fps 
		//console.log("time elapsed: " + timeElapsed);
		lastTime=nowTime;
		
		var moveAmount = timeElapsed*moveSpeed;
		var rotateAmount = timeElapsed*rotateSpeed;
		
		movePlayer([
			moveAmount*(keyThing.keystate(65)-keyThing.keystate(68)),	//lateral
			moveAmount*(keyThing.keystate(17)-keyThing.keystate(32)),	//vertical
			moveAmount*(keyThing.keystate(87)-keyThing.keystate(83)),	//fwd/back
		]);
		
		rotatePlayer([
			rotateAmount*(keyThing.keystate(40)-keyThing.keystate(38)), //pitch
			rotateAmount*(keyThing.keystate(39)-keyThing.keystate(37)), //turn
			rotateAmount*(keyThing.keystate(69)-keyThing.keystate(81)), //roll
		]);
	}
})();
var playerPosition = [0,0,0];
function movePlayer(vec){	//[left,up,forward]
	playerPosition[0] += vec[0]*playerMatrix[0] + vec[1]*playerMatrix[1] + vec[2]*playerMatrix[2];
	playerPosition[1] += vec[0]*playerMatrix[4] + vec[1]*playerMatrix[5] + vec[2]*playerMatrix[6];
	playerPosition[2] += vec[0]*playerMatrix[8] + vec[1]*playerMatrix[9] + vec[2]*playerMatrix[10];
	setPlayerTranslation(playerPosition);
	constrainPlayerPositionToBox();
}
function constrainPlayerPositionToBox(){
	if (!guiParams.keepInsideBox){return;}
	var boxSize =9.0;	//not able to go right up to the wall (full box size is 10)
	for (var ii=0;ii<3;ii++){
		if (playerPosition[ii]>boxSize){playerPosition[ii]=boxSize;}
		if (playerPosition[ii]<-boxSize){playerPosition[ii]=-boxSize;}
	}
	setPlayerTranslation(playerPosition);
}
function turnPlayer(amount){
	setPlayerTranslation([0,0,0]);

	var rotMat=mat4.identity();
	mat4.rotateY(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);
	
	setPlayerTranslation(playerPosition);
}
function rollPlayer(amount){
	setPlayerTranslation([0,0,0]);	
	
	var rotMat=mat4.identity();
	mat4.rotateZ(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);

	setPlayerTranslation(playerPosition);
}
function pitchPlayer(amount){
	setPlayerTranslation([0,0,0]);	
	
	var rotMat=mat4.identity();
	mat4.rotateX(rotMat, amount);
	mat4.multiply(rotMat, playerMatrix, playerMatrix);

	setPlayerTranslation(playerPosition);
}
function rotatePlayer(vec){
	setPlayerTranslation([0,0,0]);
	var rotationMag = Math.sqrt(vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2]);
	var rotMat=mat4.identity();
	mat4.rotate(rotMat, rotationMag, [vec[0]/rotationMag, vec[1]/rotationMag, vec[2]/rotationMag]);	//TODO find or make method taking vector instead of separate unit axis/angle
	mat4.multiply(rotMat, playerMatrix, playerMatrix);
	setPlayerTranslation(playerPosition);
}

function setPlayerTranslation(posArray){
	playerMatrix[12]=0;	//zero translation components
	playerMatrix[13]=0;
	playerMatrix[14]=0;
	mat4.translate(playerMatrix, posArray);
}

function getPointingDirectionFromScreenCoordinate(coords){
	//this is calcualated elsewhere so should probably move it
	var var1 = parseFloat(guiParams.strength)*-0.125;
	var var2 = parseFloat(10.0/guiParams.zoom);
	
	var maxyvert = var2;
	var maxxvert = var2*screenAspect;
	
	var xpos = maxxvert*(coords.x*2.0/canvas.mystylewidth   -1.0 );
	var ypos = maxyvert*(coords.y*2.0/canvas.mystyleheight   -1.0 );
	var radsq = xpos*xpos + ypos*ypos;
	var zpos = 2.0 + var1*radsq;
	
	//normalise - use sending back homogenous co-ords because maybe a tiny amount more efficient since cross producting anyway
	var mag= Math.sqrt(radsq + zpos*zpos);
	
	return {
		x: xpos,
		y: ypos,
		z: zpos,
		w: mag
	}
}

function crossProductHomgenous(dir1, dir2){
	var output ={};
	output.x = dir1.y * dir2.z - dir1.z * dir2.y; 
	output.y = dir1.z * dir2.x - dir1.x * dir2.z; 
	output.z = dir1.x * dir2.y - dir1.y * dir2.x;
	output.w = dir1.w * dir2.w;
	return output;
}

function recalculateViewParams(){

	//calculate variables that determine the viewports for single plane, 2plane, 4plane such that just enough area is covered
	//for single plane this is simplest - look at the direction shown at the corners of the screen, and set viewport with that in its corners

	//fit - set fx, fy to hFOV, vFOV - should appear to touch in middle of each screen edge
	/*
	var capFOV = 175.0;
	rttView.fx = Math.tan(Math.min(guiParams.hFOV, capFOV)*Math.PI/360.0);
	rttView.fy = Math.tan(Math.min(guiParams.vFOV, capFOV)*Math.PI/360.0);
	*/
	
	//mostly copy paste from elsewhere:
	var var1 = parseFloat(guiParams.strength)*-0.125;
	var var2 = parseFloat(10.0/guiParams.zoom);
	
	if (guiParams.indentViews){
		var2*= 0.9;	//some variable that will modify by UI, to allow showing the curved limits (for real use, should set this to 1.0/remove from code)
	}
	
	var maxyvert = var2;
	var maxxvert = var2*screenAspect;
	
	//this reproduces result of above "fit" method (bar capping).
	//rttView.fx = maxxvert / (2.0 + var1*maxxvert*maxxvert);
	//rttView.fy = maxyvert / (2.0 + var1*maxyvert*maxyvert);
	
	//fill
	var mag = 2.0 + var1*(maxxvert*maxxvert + maxyvert*maxyvert);
	var cappedmag = Math.max(0.1, mag);
	rttView.fx = maxxvert / cappedmag;
	rttView.fy = maxyvert / cappedmag;

	mag = Math.max(-8, mag);	//cap - things will screw up when vfov exceeds 180 though - where happens depends on screen aspect. pull some number out of air for now.

	//the same for 2plane.
	biplane.tan_cant_ang = -var1*maxxvert;	// (3) override tAng from satisfying simultaenous equations (1),(2)	
	//make fy such that centre top/bottom is in the right place
	var tAng = biplane.tan_cant_ang;
	var cAng = Math.cos(Math.atan(tAng));
	var sAng = Math.sin(Math.atan(tAng));
	biplane.fy = maxyvert / ( cAng*(2.0 + var1*maxyvert*maxyvert));		// (1)
	var zpos = 2.0 + var1*maxxvert*maxxvert;
	//biplane.fx = 0.5 / ( cAng*cAng*(tAng + 1.0/(maxxvert / zpos )));	//set such that right/left are fixed (halfway up screen)
	
	//set the x position of the corners - only works (to get x position on screen correct) if setting the y position too.
	var d=maxxvert / mag;
	biplane.fx =  0.5 /( cAng*cAng* (tAng + 1.0/d));
	//set fy such that corner points are in the right place (note this overrides previous setting of fy so centre top/bottom point is no longer set)
	//biplane.fy = (maxyvert/mag) / ( cAng *(1.0 + d*tAng) ); // (2)  - commented out since unnecessary now setting biplane.tan_cant_ang  - see (3)

	
	//same for quadplane.
	var zalpha = 2.0 + var1*(maxxvert*maxxvert + maxyvert*maxyvert);	//basically "mag"
	var zc = 2.0 + var1*(maxyvert*maxyvert);	//at the top/bottom of screen
	var zk = 2.0 + var1*(maxxvert*maxxvert);	//left/right. 
		//the above could be optimised...
	
	quadplane.xadjust = (zalpha -zc)/maxxvert;
	quadplane.yadjust = (zalpha -zk)/maxyvert;
	
	quadplane.fx= 1.0/( ( 2.0*zk/maxxvert ) - quadplane.xadjust );
	quadplane.fy= 1.0/( ( 2.0*zc/maxyvert ) - quadplane.yadjust );
	
	//fudge? missed a sign somewhere?
	quadplane.xadjust/=-1;
	quadplane.yadjust/=-1;
	
}

function goFullscreen(elem){
	if (elem.requestFullscreen) {
	i.requestFullscreen();
	} else if (elem.webkitRequestFullscreen) {
		elem.webkitRequestFullscreen();
	} else if (elem.mozRequestFullScreen) {
		elem.mozRequestFullScreen();
	} else if (elem.msRequestFullscreen) {
		elem.msRequestFullscreen();
	}
}

</script>



</head>



<body onload="init()">
<div id="info">Sterographic projection WebGL demo. Arrow keys or click+drag mouse to rotate, WASD, QE, space/ctrl to translate. <a href="https://github.com/filbs111/webgl-wideanglecamera" target="_blank">https://github.com/filbs111/webgl-wideanglecamera</a></div>
		

<!--<canvas id="mycanvas" width="1366" height="768">CANVAS TO GO HERE</canvas>-->
<canvas id="mycanvas" width="0" height="0">CANVAS TO GO HERE</canvas>


</body>


</html>